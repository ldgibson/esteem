function out = mocalc(atoms, xyz_a0, totalcharge, settings)
% out = mocalc(atoms,xyz_a0,totalcharge,settings)
%
% Input:
%   atoms           list of element numbers (array with K elements); e.g. [6 8] for CO
%   xyz_a0          K×3 array of Cartesian coordinates of nuclei, in bohr
%   totalcharge     total charge of the molecule, in units of elementary charge
%   settings        a structure that contains several fields
%     .basisset         string specifying the basis set, e.g. '6-31G', 'cc-pVDZ', 'STO-3G'
%     .method           string specifying the method, either 'RHF' for
%                       restricted Hatree-Fock or 'RKS' for restricted
%                       Kohn-Sham DFT
%     .ExchFunctional   string specifying the exchange functional, 'Slater'
%     .CorrFunctional   string specifying the correlation functional,
%                       'VWN3' or 'VWN5'
%     .nRadialPoints    number of radial points for the integration grid
%     .nAngularPoints   number of angular points for the integration grid
%     .tolEnergy        SCF convergence tolerance for the energy (hartrees)
%     .tolDensity       SCF convergence tolerance for the density (a_0^?3)
% Output:
%   out             a structure that contains several fields:
%     .basis        list of basis functions, as generated by buildbasis
%     .S            overlap matrix (M×M)
%     .T            kinetic energy matrix (M×M)
%     .Vne          electron-nuclear attraction matrix (M×M)
%     .J            matrix of Coulomb integrals (MxM)
%     .K            matrix of exchange integrals (MxM)
%     .Vee          electron-electron repulsion matrix (M×M) (Coulomb and exchange
%                   combined)
%     .ERI          4D array of electron-electron repulsion integrals (M×M×M×M)
%     .epsilon      MO energies (1×M), in hartrees, in ascending order, occupied
%                   and virtual orbitals
%     .C            MO coefficient matrix (M×M), of occupied and virtual orbitals,
%                   sorted in ascending order of orbital energy
%     .P            density matrix (M×M)
%     .Exc          exchange-correlation energy, in hartrees
%     .Vxc          matrix of exchange-correlation integrals (MxM), in hatrees
%     .rhoInt       integral of electron density over all of 3D space
%     .E0           electronic ground-state energy of the molecule, in hartrees
%     .Etot         total ground-state energy (including nuclear-nuclear repulsion;
%                   but without the vibrational zero-point energy), in hartrees

% Read basis set information and initialize basis functions
basissetdef = basisread(settings.basisset);
basis = buildbasis(atoms, xyz_a0, basissetdef);
M = numel(basis);
N = sum(atoms) - totalcharge;

out = struct('basis', {}, 'S', {}, 'T', {}, ...
    'Vne', {}, 'J', {}, 'K', {}, 'ERI', {}, ...
    'epsilon', {}, 'C', {}, 'P', {}, 'Exc', {}, ...
    'Vxc', {}, 'rhoInt', {}, 'E0', {}, 'Etot', {});

% Fill out structure
out(1).basis = basis;
out.S = int_overlap(out.basis);
out.T = int_kinenergy(out.basis);
out.Vne = int_attraction(atoms, xyz_a0, out.basis);
out.ERI = int_repulsion(out.basis);

Vnn = nucnucrepulsion(atoms, xyz_a0);

% Create initial guess for denisity matrix using only kinetic and
% attraction energies (instead of using sum of atomic densities)
F = out.T + out.Vne;
[C, eps] = eig(F, out.S);

[out.epsilon, idx] = sort(diag(eps));

out.C = C(:, idx);
% Normalize coefficients if not normalized
for i = 1:M
    C_N = out.C(:,i)'*out.S*out.C(:,i);
    if C_N ~= 1
        out.C(:,i) = out.C(:,i)/sqrt(C_N);
    end
end
out.P = 2*out.C(:,1:N/2)*out.C(:,1:N/2)';

% Calculate energy
out.E0 = trace(out.P*F);
out.Etot = out.E0 + Vnn;

if strcmp(settings.method, 'RKS')
    grid = molecular_grid(atoms, xyz_a0, ...
        settings.nRadialPoints, settings.nAngularPoints);
end
% SCF Procedure -----------------------------------------------------------

% Initialize convergence parameters
prevEnergy = out.Etot;
prevDensity = out.P;
convEnergy = 1;
convDensity = 1;

counter = 1;
converged = convEnergy < settings.tolEnergy ...
    && convDensity < settings.tolDensity;

while ~converged
    % Build Fock matrix
    [out.J, out.K] = eerepulsion(out.ERI, out.P);
    disp(out.J)
    disp(out.K)
    if strcmp(settings.method, 'RHF')
        F = out.T + out.Vne + (out.J - out.K);
    elseif strcmp(settings.method, 'RKS')
        [out.Vxc, out.Exc, out.rhoInt] = int_xc(out.basis, out.P, grid,...
            settings.ExchFunctional, settings.CorrFunctional);
        out.K = zeros(size(out.J));
        F = out.T + out.Vne + out.J + out.Vxc;
    end
    
    % Calculate density matrix
    [out.C, out.epsilon] = eig(F, out.S);
    [out.epsilon, idx] = sort(diag(out.epsilon));
    out.C = out.C(:, idx);
    % Normalize coefficients if not normalized
    for i = 1:M
        C_N = out.C(:,i)'*out.S*out.C(:,i);
        if C_N ~= 1
            out.C(:,i) = out.C(:,i)/sqrt(C_N);
        end
    end
    out.P = 2*out.C(:,1:N/2)*out.C(:,1:N/2)';

    % Calculate energy
    if strcmp(settings.method, 'RHF')
        A = out.T + out.Vne + 0.5*(out.J - out.K);
        out.E0 = trace(out.P*A);
    elseif strcmp(settings.method, 'RKS')
        A = out.T + out.Vne + 0.5*out.J;
        out.E0 = trace(out.P*A) + out.Exc;
    end
    out.Etot = out.E0 + Vnn;
    
    % Calculate convergence
    convEnergy = abs(prevEnergy - out.Etot);
    convDensity = max(abs(prevDensity - out.P), [], 'all');
    prevEnergy = out.Etot;
    prevDensity = out.P;
    
    converged = convEnergy < settings.tolEnergy ...
        && convDensity < settings.tolDensity;
    
    % Print the progress
    fprintf('i = %d\tE = %13.10f  E_conv = %13.10f  P_conv = %13.10f\n',...
        counter, prevEnergy, convEnergy, convDensity);
    counter = counter + 1;
end

end

    