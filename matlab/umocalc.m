function out = umocalc(atoms, xyz_a0, totalcharge, settings)
% out = mocalc(atoms,xyz_a0,totalcharge,settings)
%
% Input:
%   atoms           list of element numbers (array with K elements); e.g. [6 8] for CO
%   xyz_a0          K×3 array of Cartesian coordinates of nuclei, in bohr
%   totalcharge     total charge of the molecule, in units of elementary charge
%   settings        a structure that contains several fields
%     .basisset         string specifying the basis set, e.g. '6-31G', 'cc-pVDZ', 'STO-3G'
%     .method           string specifying the method, either 'RHF' for
%                       restricted Hatree-Fock or 'RKS' for restricted
%                       Kohn-Sham DFT
%     .ExchFunctional   string specifying the exchange functional, 'Slater'
%     .CorrFunctional   string specifying the correlation functional,
%                       'VWN3' or 'VWN5'
%     .nRadialPoints    number of radial points for the integration grid
%     .nAngularPoints   number of angular points for the integration grid
%     .tolEnergy        SCF convergence tolerance for the energy (hartrees)
%     .tolDensity       SCF convergence tolerance for the density (a_0^?3)
% Output:
%   out             a structure that contains several fields:
%     .basis        list of basis functions, as generated by buildbasis
%     .S            overlap matrix (M×M)
%     .T            kinetic energy matrix (M×M)
%     .Vne          electron-nuclear attraction matrix (M×M)
%     .J            matrix of Coulomb integrals (MxM)
%     .K            matrix of exchange integrals (MxM)
%     .Vee          electron-electron repulsion matrix (M×M) (Coulomb and exchange
%                   combined)
%     .ERI          4D array of electron-electron repulsion integrals (M×M×M×M)
%     .epsilon      MO energies (1×M), in hartrees, in ascending order, occupied
%                   and virtual orbitals
%     .C            MO coefficient matrix (M×M), of occupied and virtual orbitals,
%                   sorted in ascending order of orbital energy
%     .P            density matrix (M×M)
%     .Exc          exchange-correlation energy, in hartrees
%     .Vxc          matrix of exchange-correlation integrals (MxM), in hatrees
%     .rhoInt       integral of electron density over all of 3D space
%     .E0           electronic ground-state energy of the molecule, in hartrees
%     .Etot         total ground-state energy (including nuclear-nuclear repulsion;
%                   but without the vibrational zero-point energy), in hartrees

% Read basis set information and initialize basis functions
basissetdef = basisread(settings.basisset);
basis = buildbasis(atoms, xyz_a0, basissetdef);
M = numel(basis);
N = sum(atoms) - totalcharge;

if isfield(settings, 'multiplicity')
    N_unpaired_electrons = settings.multiplicity - 1;
    Nb = (N - N_unpaired_electrons)/2;
    Na = Nb + N_unpaired_electrons;
else
    Nb = N/2;
    Na = Nb;
end

% out = struct('basis', {}, 'S', {}, 'T', {}, ...
%     'Vne', {}, 'J', {}, 'K', {}, 'ERI', {}, ...
%     'epsilon_alpha', {}, 'C', {}, 'P', {}, 'Exc', {}, ...
%     'Vxc', {}, 'rhoInt', {}, 'E0', {}, 'Etot', {});

% Fill out structure
out.basis = basis;
out.S = int_overlap(out.basis);
out.T = int_kinenergy(out.basis);
out.Vne = int_attraction(atoms, xyz_a0, out.basis);
out.ERI = int_repulsion(out.basis);

Vnn = nucnucrepulsion(atoms, xyz_a0);

% Create initial guess for denisity matrix using only kinetic and
% attraction energies (instead of using sum of atomic densities)
F = out.T + out.Vne;
[C, eps] = eig(F, out.S);
[out.epsilon_a, idx] = sort(diag(eps));
out.epsilon_b = out.epsilon_a;
out.Ca = C(:, idx);
out.Cb = out.Ca;

% Normalize coefficients if not normalized
for i = 1:M
    C_N = out.Ca(:,i)'*out.S*out.Ca(:,i);
    if C_N ~= 1
        out.Ca(:,i) = out.Ca(:,i)/sqrt(C_N);
    end
end
for i = 1:M
    C_N = out.Cb(:,i)'*out.S*out.Cb(:,i);
    if C_N ~= 1
        out.Cb(:,i) = out.Cb(:,i)/sqrt(C_N);
    end
end
out.Pa = out.Ca(:,1:Na)*out.Ca(:,1:Na)';
out.Pb = out.Cb(:,1:Nb)*out.Cb(:,1:Nb)';

% Calculate energy
A_a = (1/2)*(out.T + out.Vne);
A_b = (1/2)*(out.T + out.Vne);
% A = out.T + out.Vne + 0.5*(out.J - out.K);
out.E0 = trace(out.Pa*A_a) + trace(out.Pb*A_b);
out.Etot = out.E0 + Vnn;

if strcmp(settings.method, 'UKS')
    grid = molecular_grid(atoms, xyz_a0, ...
        settings.nRadialPoints, settings.nAngularPoints);
end

% SCF Procedure -----------------------------------------------------------

% Initialize convergence parameters
prevEnergy = out.Etot;
prevDensityAlpha = out.Pa;
prevDensityBeta = out.Pb;
convEnergy = 1;
convDensityAlpha = 1;
convDensityBeta = 1;

counter = 1;
converged = convEnergy < settings.tolEnergy ...
    && convDensityAlpha < settings.tolDensity ...
    && convDensityBeta < settings.tolDensity;

while ~converged
    % Build Fock matrix
    [out.Ja, out.Ka] = eerepulsion(out.ERI, out.Pa);
    [out.Jb, out.Kb] = eerepulsion(out.ERI, out.Pb);
    
    % Corrects the 0.5 factor from RHF calculations
    out.Ka = 2*out.Ka;
    out.Kb = 2*out.Kb;
    
    out.J = out.Ja + out.Jb;
    if strcmp(settings.method, 'UHF')
        Fa = out.T + out.Vne + (out.J - out.Ka);
        Fb = out.T + out.Vne + (out.J - out.Kb);
    elseif strcmp(settings.method, 'UKS')
        [out.Vxc, out.Exc, out.rhoInt] = int_xc(out.basis, out.P, grid,...
            settings.ExchFunctional, settings.CorrFunctional);
        out.K = zeros(size(out.J));
        F = out.T + out.Vne + out.J + out.Vxc;
    end
    
    % Calculate density matrix
    [out.Ca, out.epsilon_a] = eig(Fa, out.S);
    [out.Cb, out.epsilon_b] = eig(Fb, out.S);
    [out.epsilon_a, idxa] = sort(diag(out.epsilon_a));
    [out.epsilon_b, idxb] = sort(diag(out.epsilon_b));
    out.Ca = out.Ca(:, idxa);
    out.Cb = out.Cb(:, idxb);
    % Normalize coefficients if not normalized
    for i = 1:M
        C_N_a = out.Ca(:,i)'*out.S*out.Ca(:,i);
        C_N_b = out.Cb(:,i)'*out.S*out.Cb(:,i);
        if C_N_a ~= 1
            out.Ca(:,i) = out.Ca(:,i)/sqrt(C_N_a);
        end
        if C_N_b ~= 1
            out.Cb(:,i) = out.Cb(:,i)/sqrt(C_N_b);
        end
    end
    out.Pa = out.Ca(:,1:Na)*out.Ca(:,1:Na)';
    out.Pb = out.Cb(:,1:Nb)*out.Cb(:,1:Nb)';

    % Calculate energy
    if strcmp(settings.method, 'UHF')
        A_a = (1/2)*(out.T + out.Vne + Fa);
        A_b = (1/2)*(out.T + out.Vne + Fb);
        % A = out.T + out.Vne + 0.5*(out.J - out.K);
        out.E0 = trace(out.Pa*A_a) + trace(out.Pb*A_b);
    elseif strcmp(settings.method, 'UKS')
        A = out.T + out.Vne + 0.5*out.J;
        out.E0 = trace(out.P*A) + out.Exc;
    end
    out.Etot = out.E0 + Vnn;
    
    % Calculate convergence
    convEnergy = abs(prevEnergy - out.Etot);
    convDensityAlpha = max(abs(prevDensityAlpha - out.Pa), [], 'all');
    convDensityBeta = max(abs(prevDensityBeta - out.Pb), [], 'all');
    prevEnergy = out.Etot;
    prevDensityAlpha = out.Pa;
    prevDensityBeta = out.Pb;
    
    converged = convEnergy < settings.tolEnergy ...
        && convDensityAlpha < settings.tolDensity ...
        && convDensityBeta < settings.tolDensity;
    
    % Print the progress
%     fprintf('i = %d\tE = %13.10f  E_conv = %13.10f  P_conv = %13.10f\n',...
%         counter, prevEnergy, convEnergy, convDensity);
    counter = counter + 1;
end

end

    